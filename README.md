# Welcome to the demo

We will implement a reading on the [pebble-simulator](https://github.com/iotexproject/pebble-simulator) and to sign that reading with [PyCrypto](https://github.com/Zokrates/pycrypto). This signed reading will then be verified in [ZoKrates](https://github.com/ZK-Plus/ZoKrates). ZoKrates will provide us with an verifier contract that we will deploy on the [IoTeX Network Testnet](https://docs.iotex.io/the-iotex-stack/iotx-faucets/testnet-tokens) via [Remix IDE](https://remix.ethereum.org) and a proof that we will provide onchain to show the verification of the readings signature. 

## MetaMask

Install a browser plugin of [MetaMask](https://metamask.io/). Follow the instructions that apply for you, new private key, recover or just add a new account.

## IoTeX

Register via github and caim daily IOTX on your [developer profile](https://developers.iotex.io/user/profile).


## Peabble Simulator 

Set Number of Data Points to 1 and config privkey to: 46a44b42846312eee2f16708c1c508de917ac42703cbd0531281cafb5857a51 (not nessesary now, but later).


<!--Public Key: x=14897476871502190904409029696666322856887678969656209656241038339251270171395, y=16668832459046858928951622951481252834155254151733002984053501254009901876174-->


```
========>> PEBBLE SIMULATOR <<========


 1.  Config Sensors

 2.  Set Number of Data Points (Current: 1)

 3.  Generate Simulated Data

 4.  Publish to IoTT Portal

 5.  Device Registration

 6.  Set Device IMEI (Current: 103381234567406)

 7.  Config device privkey (Current: 46a44b42846312eee2f16708c1c508de917ac42703cbd0531281cafb5857a51)

 8.  Networks (Current: testnet)

 9.  Exit

Select:
```
Generate Simulated Data. This will create a **pebble.dat** file containing the data in the root folder of the pebble-simulator.

## PyCrypto

Create a new file in the root folder **demo.py**.

```
import hashlib
import os
import json

from zokrates_pycrypto.eddsa import PrivateKey, PublicKey
from zokrates_pycrypto.field import FQ
from zokrates_pycrypto.utils import write_signature_for_zokrates_cli

pebble_path = os.path.join(os.pardir, 'pebble-simulator/pebble.dat')

if __name__ == "__main__":
    with open(pebble_path, 'rb') as file:
        pebble_data = json.load(file)
        timestamp = pebble_data['message']['timestamp']
    print(timestamp)
    msg = timestamp.encode('utf-8')
    print(msg)
    msg = hashlib.sha512(msg).digest()
    print(msg)
    # Seeded for debug purpose
    key = FQ(1997011358982923168928344992199991480689546837621580239342656433234255379025)
    sk = PrivateKey(key)
    sig = sk.sign(msg)
    print(sig)

    pk = PublicKey.from_private(sk)
    print(pk.p)

    is_verified = pk.verify(sig, msg)
    print(is_verified)

    path = 'zokrates_inputs.txt'
    write_signature_for_zokrates_cli(pk, sig, msg, path)

```
Run **python demo.py** and the script will load the JSON  in the pebble.dat, identify the timestamp, sign it and write a zokrates_inputs.txt containing the wittness inputs for ZoKrates.

# Remix

Open [Remix online IDE](https://remix.ethereum.org) and install ZoKrates with the plugin manager. Klick on **deploy and run transactions** and choose WalletConection in the Environment. 

If you wallet does not connect Remix IDE, klick on the plug symbol right from Environment to be forwarded to **chainlist** where you search for IoTeX and include testnets. Connect with your wallet and return to **Remix online IDE** that should now allow you to connect to your wallet. 

## File Explorer

Switch to the file explorer tab on the left side and add a new file **root.zok**. 

```
from "ecc/babyjubjubParams" import BabyJubJubParams;
import "signatures/verifyEddsa.zok" as verifyEddsa;
import "ecc/babyjubjubParams.zok" as context;

def main(private field[2] R, private field S, field[2] A, u32[8] M0, u32[8] M1) -> () {
    BabyJubJubParams context = context();
	assert(verifyEddsa(R, S, A, M0, M1, context));
}

```

## ZoKrates

Switch to the ZoKrates tab on the left side and choose GM17 as prooving scheme. Then compile. Then compute and enter the inputs generated by the **zokrates_inputs.txt**. Note: If ZoKrates is missing inputs then just add a 0 for each missing input in the M0 and M1 section. Run the setup. Generate the proof. Export to create the **verifier.sol**.

## Solidity compiler

Switch to the Solidity compiler to the left and compile the **verifier.sol**.

## Deploy and run transactions

Switch to the Deploy and run transactions to the left and choose the **Verifier - verifier.sol** in Contract and Deploy. Confirm the transaction in MetaMask two times.

Open the verifier contract in **Deployed/Unpinned Contracts** and pin the contract.


You can now look the contract up on [iotexcan](https://testnet.iotexscan.io). 


# Issues

- I have not figured out how the signing works in PyCrypto without hashing the input, I guess ZoKrates for now needs the size of the output for the EdDSA verification. This will be crusial for calculations.


- And I did not figure out how/where to insert the proof in Remix or where ever to get an anser if the proof is correct.

